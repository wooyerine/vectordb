{
	"level": [
		"h",
		"m",
		"e"
	],
	"pNumber": [
		3139,
		3138,
		3136
	],
	"category": [
		"Array, Greedy, Enumeration",
		"Hash Table, String, Counting",
		"String"
	],
	"title": [
		"[3139] Minimum Cost to Equalize Array  ",
		"[3138] Minimum Length of Anagram Concatenation  ",
		"[3136] Valid Word  "
	],
	"description": [
		"You are given an integer array nums and two integers cost1 and cost2. You are allowed to perform either of the following operations any number of times:\tChoose an index i from nums and increase nums[i] by 1 for a cost of cost1.\tChoose two different indices i, j, from nums and increase nums[i] and nums[j] by 1 for a cost of cost2.Return the minimum cost required to make all elements in the array equal. Since the answer may be very large, return it modulo 10^9 + 7.\u00a0Example 1:Input: nums = [4,1], cost1 = 5, cost2 = 2Output: 15Explanation: The following operations can be performed to make the values equal:\tIncrease nums[1] by 1 for a cost of 5. nums becomes [4,2].\tIncrease nums[1] by 1 for a cost of 5. nums becomes [4,3].\tIncrease nums[1] by 1 for a cost of 5. nums becomes [4,4].The total cost is 15.Example 2:Input: nums = [2,3,3,3,5], cost1 = 2, cost2 = 1Output: 6Explanation: The following operations can be performed to make the values equal:\tIncrease nums[0] and nums[1] by 1 for a cost of 1. nums becomes [3,4,3,3,5].\tIncrease nums[0] and nums[2] by 1 for a cost of 1. nums becomes [4,4,4,3,5].\tIncrease nums[0] and nums[3] by 1 for a cost of 1. nums becomes [5,4,4,4,5].\tIncrease nums[1] and nums[2] by 1 for a cost of 1. nums becomes [5,5,5,4,5].\tIncrease nums[3] by 1 for a cost of 2. nums becomes [5,5,5,5,5].The total cost is 6.Example 3:Input: nums = [3,5,3], cost1 = 1, cost2 = 3Output: 4Explanation:The following operations can be performed to make the values equal:\tIncrease nums[0] by 1 for a cost of 1. nums becomes [4,5,3].\tIncrease nums[0] by 1 for a cost of 1. nums becomes [5,5,3].\tIncrease nums[2] by 1 for a cost of 1. nums becomes [5,5,4].\tIncrease nums[2] by 1 for a cost of 1. nums becomes [5,5,5].The total cost is 4.\u00a0Constraints:\t1 <= nums.length <= 10^5\t1 <= nums[i] <= 10^6\t1 <= cost1 <= 10^6\t1 <= cost2 <= 10^6",
		"You are given a string s, which is known to be a concatenation of anagrams of some string t.Return the minimum possible length of the string t.An anagram is formed by rearranging the letters of a string. For example, \"aab\", \"aba\", and, \"baa\" are anagrams of \"aab\".\u00a0Example 1:Input: s = \"abba\"Output: 2Explanation:One possible string t could be \"ba\".Example 2:Input: s = \"cdef\"Output: 4Explanation:One possible string t could be \"cdef\", notice that t can be equal to s.\u00a0Constraints:\t1 <= s.length <= 10^5\ts consist only of lowercase English letters.",
		"A word is considered valid if:\tIt contains a minimum of 3 characters.\tIt contains only digits (0-9), and English letters (uppercase and lowercase).\tIt includes at least one vowel.\tIt includes at least one consonant.You are given a string word.Return true if word is valid, otherwise, return false.Notes:\t'a', 'e', 'i', 'o', 'u', and their uppercases are vowels.\tA consonant is an English letter that is not a vowel.\u00a0Example 1:Input: word = \"234Adas\"Output: trueExplanation:This word satisfies the conditions.Example 2:Input: word = \"b3\"Output: falseExplanation:The length of this word is fewer than 3, and does not have a vowel.Example 3:Input: word = \"a3$e\"Output: falseExplanation:This word contains a '$' character and does not have a consonant.\u00a0Constraints:\t1 <= word.length <= 20\tword consists of English uppercase and lowercase letters, digits, '@', '#', and '$'."
	],
	"example": [
		"Example 1:Input: nums = [4,1], cost1 = 5, cost2 = 2Output: 15Explanation: The following operations can be performed to make the values equal:\tIncrease nums[1] by 1 for a cost of 5. nums becomes [4,2].\tIncrease nums[1] by 1 for a cost of 5. nums becomes [4,3].\tIncrease nums[1] by 1 for a cost of 5. nums becomes [4,4].The total cost is 15.Example 2:Input: nums = [2,3,3,3,5], cost1 = 2, cost2 = 1Output: 6Explanation: The following operations can be performed to make the values equal:\tIncrease nums[0] and nums[1] by 1 for a cost of 1. nums becomes [3,4,3,3,5].\tIncrease nums[0] and nums[2] by 1 for a cost of 1. nums becomes [4,4,4,3,5].\tIncrease nums[0] and nums[3] by 1 for a cost of 1. nums becomes [5,4,4,4,5].\tIncrease nums[1] and nums[2] by 1 for a cost of 1. nums becomes [5,5,5,4,5].\tIncrease nums[3] by 1 for a cost of 2. nums becomes [5,5,5,5,5].The total cost is 6.Example 3:Input: nums = [3,5,3], cost1 = 1, cost2 = 3Output: 4Explanation:The following operations can be performed to make the values equal:\tIncrease nums[0] by 1 for a cost of 1. nums becomes [4,5,3].\tIncrease nums[0] by 1 for a cost of 1. nums becomes [5,5,3].\tIncrease nums[2] by 1 for a cost of 1. nums becomes [5,5,4].\tIncrease nums[2] by 1 for a cost of 1. nums becomes [5,5,5].The total cost is 4.",
		"Example 1:Input: s = \"abba\"Output: 2Explanation:One possible string t could be \"ba\".Example 2:Input: s = \"cdef\"Output: 4Explanation:One possible string t could be \"cdef\", notice that t can be equal to s.",
		"Example 1:Input: word = \"234Adas\"Output: trueExplanation:This word satisfies the conditions.Example 2:Input: word = \"b3\"Output: falseExplanation:The length of this word is fewer than 3, and does not have a vowel.Example 3:Input: word = \"a3$e\"Output: falseExplanation:This word contains a '$' character and does not have a consonant."
	],
	"constraints": [
		"Constraints:\t1 <= nums.length <= 10^5\t1 <= nums[i] <= 10^6\t1 <= cost1 <= 10^6\t1 <= cost2 <= 10^6",
		"Constraints:\t1 <= s.length <= 10^5\ts consist only of lowercase English letters.",
		"Constraints:\t1 <= word.length <= 20\tword consists of English uppercase and lowercase letters, digits, '@', '#', and '$'."
	],
	"output": [
		"class Solution:\n    def minCostToEqualizeArray(self, nums: List[int], cost1: int, cost2: int) -> int:\n        \n",
		"class Solution:\n    def minAnagramLength(self, s: str) -> int:\n        \n",
		"class Solution:\n    def isValid(self, word: str) -> bool:\n        \n"
	],
	"answer": [
		"class Solution:\n    def minCostToEqualizeArray(self, nums: List[int], cost1: int, cost2: int) -> int:\n        n, mx, mod = len(nums), max(nums), 10**9+7\n        maxGap, ttlGap = mx-min(nums), mx*n-sum(nums)\n        \n        if cost1*2 <= cost2:\n            # Easy case, Op 1\n            return ttlGap*cost1 % mod\n        \n        if maxGap*2 <= ttlGap:\n            # The maxGap is less than a half of ttlGap, we can always find pairs for Op 2\n            res =  ttlGap // 2 * cost2\n            if ttlGap % 2 == 1:\n                # Corner case with the last one spot left\n                if n % 2 == 1:\n                    res += min(cost1, cost2 * (n+1) // 2)\n                else:\n                    res += cost1\n            return res % mod\n        \n        # Two Operations:\n        #   Op 1: Directly fill maxGap\n        #   Op 2: Pair maxGap with other nums, which increases the final level.\n\n        res = cost2 * (ttlGap - maxGap)\n        maxGap -= ttlGap - maxGap\n\n        if maxGap >= n-1:\n        \n            if cost2 * (n-1) >= cost1 * (n-2):\n                # Op 1 is better\n                res += maxGap // (n-1) * (n-1) * cost1\n                maxGap %= n-1\n            else:\n                # Op 2 is better\n                res += maxGap // (n-2) * (n-1) * cost2\n                maxGap %= n-2\n\n        if maxGap:\n            # For the last round, Op 2: Increase the level by 1 to get (n+maxGap)//2 pairs\n            op2 = (n+maxGap) // 2 * cost2 # = (maxGap + (n-maxGap)//2) * cost2\n            if (n+maxGap) % 2 == 1:\n                # The last one spot left\n                if n%2 == 1:\n                    op2 += min(cost1, cost2*(n+1)//2)\n                else:\n                    op2 += cost1\n\n            # Compare it with Op 1 \n            res += min(op2, maxGap * cost1)\n\n        return res % mod",
		"class Solution:\n    def minAnagramLength(self, s: str) -> int:\n        stringList = list(s)\n        n = len(s)\n        for size in range(1, n):\n            if n % size == 0: \n                initialList = sorted(stringList[:size])\n                for j in range(size, n, size):\n                    temp = stringList[j:j+size]\n                    temp.sort()\n\n                    if initialList != temp: \n                        break\n                else:\n                    return size\n                    \n        return n",
		"class Solution:\n    def isValid(self, word: str) -> bool:\n        al = 'abcdefghijklmnopqrstuvwxyz'\n        l, u = False, False\n        c, v = False, False\n        d = False\n        for i in word:\n            if i.isupper():\n                if i.lower() in 'aeiou':\n                    v = True\n                elif i.lower() in al:\n                    c = True\n                u = True\n            elif i.islower():\n                if i in 'aeiou':\n                    v = True\n                elif i in al:\n                    c = True\n                l = True\n            elif i.isdigit():\n                d = True\n            else:\n                return False\n        an = int(u) + int(l) + int(d)\n        return len(word) >= 3 and an > 0 and c and v"
	]
}
